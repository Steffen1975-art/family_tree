<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktiver Stammbaum - Familien Koller & Holl & Maier</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            margin: 0;
            overflow: hidden; /* Prevent body scrollbars */
        }

        /* SVG container styling */
        #tree-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Styling for the connecting lines (links) */
        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 2px;
            transition: stroke 0.5s ease;
        }

        /* Styling for the person nodes */
        .node {
            cursor: pointer;
            font-size: 15px;
        }

        .node circle {
            stroke: #38bdf8;
            stroke-width: 2.5px;
            transition: fill 0.3s ease, transform 0.3s ease, stroke 0.3s ease;
        }
        
        /* Highlighting styles */
        .node.highlight circle {
            stroke: #f43f5e; /* Rose 500 for main selection */
            fill: #ffe4e6;
            stroke-width: 3px;
            transform: scale(1.2);
        }
        
        .node.descendant-highlight circle {
            stroke: #22c55e; /* Green 500 for descendants */
            fill: #dcfce7;
        }

        .link.descendant-highlight {
            stroke: #16a34a; /* Green 600 for descendant links */
            stroke-width: 3px;
        }

        .node text {
            font-weight: 500;
            paint-order: stroke;
            stroke: #f8fafc;
            stroke-width: 3.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }
        
        .node:hover circle {
            transform: scale(1.1);
        }
        
        /* Controls Panel */
        .panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .panel-header {
            padding: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header svg {
            width: 1.25rem;
            height: 1.25rem;
            transition: transform 0.3s ease;
        }

        .panel-content {
            padding: 0 0.75rem 0.75rem 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out;
            max-height: 1000px;
            opacity: 1;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .panel.collapsed .panel-header svg {
            transform: rotate(-90deg);
        }

        .panel .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .panel .control-row {
             display: flex;
             align-items: center;
             justify-content: space-between;
        }

        .panel label {
            margin-right: 0.75rem;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .panel select, .panel input[type="text"] {
            border-radius: 6px;
            border: 1px solid #d1d5db;
            padding: 0.25rem 0.5rem;
            width: 100%;
        }
        
        .panel button {
            width: 100%;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid transparent;
            background-color: #f3f4f6;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .panel button:hover {
            background-color: #e5e7eb;
        }
        .panel button.primary {
            background-color: #0ea5e9;
            color: white;
        }
        .panel button.primary:hover {
            background-color: #0284c7;
        }

        .view-switcher label {
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .view-switcher input[type="radio"] {
            display: none;
        }
        .view-switcher input[type="radio"]:checked + label {
            background-color: #38bdf8;
            color: white;
        }
        .view-switcher label:not(input[type="radio"]:checked + label):hover {
            background-color: #f1f5f9;
        }
        
        /* Search specific styles */
        .search-container {
            position: relative;
        }
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 30;
        }
        .search-result-item {
            padding: 0.5rem;
            cursor: pointer;
        }
        .search-result-item:hover {
            background-color: #f1f5f9;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 12px;
            font-size: 0.875rem;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            max-width: 350px;
            z-index: 10;
        }
        .tooltip .name { font-weight: 700; color: #0c4a6e; font-size: 1rem; margin-bottom: 8px; }
        .tooltip .details p { margin: 4px 0; }
        .tooltip .details strong { color: #334155; }
    </style>
</head>
<body>

    <div class="absolute top-0 left-0 p-4 md:p-6 z-10 w-full bg-gradient-to-b from-white via-white/80 to-transparent pointer-events-none">
        <h1 id="main-title" class="text-2xl md:text-3xl font-bold text-sky-800">Ahnengalerie</h1>
        <p class="text-slate-600 mt-1 text-sm md:text-base">Ansicht wählen, Knoten anklicken, Zoomen & Verschieben.</p>
    </div>

    <div id="controls-container" class="panel">
        <!-- JS will populate this -->
    </div>

    <div id="tree-container"></div>

    <div id="tooltip" class="tooltip">
        <div id="tooltip-name" class="name"></div>
        <div id="tooltip-details" class="details"></div>
    </div>

    <script>
        // --- DATA SECTION ---
        // Single Source of Truth: All individuals in a flat array.
        // Relationships are handled by IDs (fatherId, motherId, spouseIds, childrenIds).
        const peopleData = [
            // Root Ancestors
            { id: 1, name: "Johann Koller", details: { geboren: "1807", gestorben: "02.09.1881", info: "Heirat 1831 mit Franziska geb. Müller (1807-1892)." }, spouseIds: [2], childrenIds: [3, 4] },
            { id: 2, name: "Franziska Müller", details: { geboren: "1807", gestorben: "1892" } },
            
            // Children of Johann Koller
            { id: 3, name: "Xaver Koller", details: { geboren: "24.11.1832", gestorben: "13.04.1919" }, fatherId: 1, motherId: 2 },
            { id: 4, name: "Georg Koller", details: { geboren: "22.07.1843", gestorben: "21.07.1928", info: "Heirat 07.01.1873 mit Therese geb. Röck (1850-1923)." }, fatherId: 1, motherId: 2, spouseIds: [5], childrenIds: [6, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119] },
            { id: 5, name: "Therese Röck", details: { geboren: "1850", gestorben: "1923" } },

            // Children of Georg Koller (ID 4)
            { id: 6, name: "Andreas Koller", details: { geboren: "01.01.1874", gestorben: "10.05.1959", info: "Heirat 02.05.1898 mit Therese geb. Stadler (1873-1960)." }, fatherId: 4, motherId: 5, spouseIds: [7], childrenIds: [8, 9, 10, 11, 12, 13] },
            { id: 7, name: "Therese Stadler", details: { geboren: "1873", gestorben: "1960" } },
            
            // Grandchildren of Georg Koller (ID 4) -> Children of Andreas Koller (ID 6)
            { id: 8, name: "Therese Vogl", details: { geboren: "15.04.1899", gestorben: "20.03.1974", info: "geb. Koller. Heirat 19.10.1921 mit Xaver Vogl (1897-1958)." }, fatherId: 6, motherId: 7 },
            { id: 9, name: "Andreas Koller", details: { geboren: "29.11.1902", gestorben: "14.04.1944", info: "Heirat 23.11.1925 mit Maria geb. Schreil (1901-1944)." }, fatherId: 6, motherId: 7 },
            { id: 10, name: "Franz-Xaver Koller", details: { geboren: "20.05.1904", gestorben: "05.04.1962", info: "Heirat 22.10.1928 mit Thekla geb. Vogl (1900-1974)." }, fatherId: 6, motherId: 7 },
            { id: 11, name: "Franziska Koller", details: { geboren: "04.07.1906", gestorben: "unbekannt" }, fatherId: 6, motherId: 7 },
            { id: 12, name: "Maria Koller", details: { geboren: "06.12.1907", gestorben: "unbekannt" }, fatherId: 6, motherId: 7 },
            { id: 13, name: "Max Koller", details: { geboren: "25.09.1910", gestorben: "06.11.1937", info: "Heirat 24.05.1937 mit Johanna geb. Englmeier (1914-unbekannt)." }, fatherId: 6, motherId: 7 },
            
            // ... other children of Georg Koller (ID 4)
            { id: 110, name: "Georg Koller", details: { geboren: "26.02.1876", gestorben: "04.10.1954", info: "Heirat mit Centa (Daten unbekannt)." }, fatherId: 4, motherId: 5, childrenIds: [1101, 1102] },
            { id: 1101, name: "Georg Koller", details: { info: "Daten unbekannt." }, fatherId: 110 },
            { id: 1102, name: "Willibald Koller", details: { info: "Daten unbekannt." }, fatherId: 110 },
            
            { id: 111, name: "Franz Koller", details: { geboren: "19.03.1878", gestorben: "09.11.1933", info: "Heirat 26.01.1902 mit Anna geb. Weikl (1882-1928)." }, fatherId: 4, motherId: 5, childrenIds: [1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 11110, 11111, 11112, 11113, 11114] },
            { id: 1111, name: "Anna Wölfl", details: { geboren: "12.08.1902", gestorben: "12.08.1989", info: "geb. Koller. Heirat 25.11.1926 mit Michael Wölfl (1901-1981)." }, fatherId: 111 },
            { id: 1112, name: "Wilhelmine Kroner", details: { geboren: "29.09.1903", gestorben: "20.01.1988", info: "geb. Koller. Heirat 16.11.1933 mit Johann Kroner (1903-1969)." }, fatherId: 111 },
            { id: 1113, name: "Therese Weinberger", details: { geboren: "31.01.1905", gestorben: "28.02.1964", info: "geb. Koller. Heirat 11.11.1926 mit Franz Weinberger (1901-1974)." }, fatherId: 111 },
            { id: 1114, name: "Franz Koller", details: { geboren: "04.10.1906", gestorben: "vermisst 1945", info: "Heirat 04.02.1935 mit Veronika geb. Kroner (1909-1969)." }, fatherId: 111 },
            { id: 1115, name: "Georg Koller", details: { geboren: "09.01.1908", gestorben: "24.09.1991", info: "Heirat 21.04.1958 mit Anna geb. Wühr (1919-2005)." }, fatherId: 111 },
            { id: 1116, name: "Heinrich Koller", details: { geboren: "22.06.1909", gestorben: "04.05.1986" }, fatherId: 111 },
            { id: 1117, name: "Andreas Koller", details: { geboren: "15.10.1910", gestorben: "16.11.1944" }, fatherId: 111 },
            { id: 1118, name: "Ludwig Koller", details: { geboren: "24.08.1912", gestorben: "06.01.1976", info: "Heirat 07.02.1936 mit Wilhelmine geb. Stoiber (1912-1994)." }, fatherId: 111 },
            { id: 1119, name: "Maria Koller", details: { geboren: "15.01.1914", gestorben: "22.10.1915" }, fatherId: 111 },
            { id: 11110, name: "Maria-Josefa Koller", details: { geboren: "17.09.1915" }, fatherId: 111 },
            { id: 11111, name: "Babette Koller", details: { geboren: "10.02.1917" }, fatherId: 111 },
            { id: 11112, name: "Rosa Koller", details: { geboren: "14.11.1918", gestorben: "09.05.1987" }, fatherId: 111 },
            { id: 11113, name: "Frieda Koller", details: { geboren: "18.06.1921" }, fatherId: 111 },
            { id: 11114, name: "Pauline Koller", details: { geboren: "16.11.1924" }, fatherId: 111 },

            { id: 112, name: "Baptist Koller", details: { geboren: "20.06.1880", gestorben: "27.08.1963", info: "Heirat mit Berta geb. Wenzl (1882-1961)." }, fatherId: 4, motherId: 5, childrenIds: [1121] },
            { id: 1121, name: "Baptist Koller", details: { geboren: "20.07.1902", gestorben: "18.04.1972", info: "Heirat 01.10.1930 mit Sophie Hinkofer (1906-1987)." }, fatherId: 112 },

            { id: 113, name: "Tobias Koller", details: { geboren: "10.09.1882", gestorben: "18.01.1965", info: "1. Ehe (24.09.1906) mit Cäzilia geb. Weber (1883-1916). 2. Ehe (22.04.1918) mit Maria Treml (1892-1980)." }, fatherId: 4, motherId: 5, childrenIds: [1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 11310, 11311, 11312, 11313, 11314, 11315, 11316] },
            // ... children of Tobias Koller
            
            { id: 119, name: "Sylvester Koller", details: { geboren: "23.07.1893", gestorben: "24.03.1974", info: "Heirat 06.03.1916 mit Mathilde geb. Hinkofer (1895-1974)." }, fatherId: 4, motherId: 5, spouseIds: [120], childrenIds: [121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132] },
            { id: 120, name: "Mathilde Hinkofer", details: { geboren: "1895", gestorben: "1974" } },

            { id: 122, name: "Wolfgang Koller", details: { geboren: "30.10.1918", gestorben: "04.02.1996", info: "Heirat 24.01.1946 mit Rosina geb. Adam (1922-1999)." }, fatherId: 119, motherId: 120, spouseIds: [1221], childrenIds: [1222, 1223, 1224, 1225, 1226, 1227] },
            { id: 1221, name: "Rosina Adam", details: { geboren: "1922", gestorben: "1999" } },
            // ... other children of Sylvester Koller

            // --- MERGED & CENTRAL PEOPLE ---
            { id: 127, name: "Maria Hubert", details: { geboren: "19.04.1928", info: "geb. Koller. Lebensgefährte Franz Xaver Schreiner (1919-1972). Heirat 10.05.1958 mit Alfons Georg Hubert (1907-1997)." }, fatherId: 119, motherId: 120, spouseIds: [1271, 1272], childrenIds: [1273, 1274, 1275, 1276] },
            { id: 1271, name: "Franz Xaver Schreiner", details: { geboren: "1919", gestorben: "1972" } },
            { id: 1272, name: "Alfons Georg Hubert", details: { geboren: "1907", gestorben: "1997" } },
            
            { id: 1273, name: "Sylvester Koller", details: { geboren: "08.04.1949", info: "Sohn von Franz Schreiner. Heirat 08.09.1972 mit Christa Koller (geb. Holl, *07.11.1951)." }, fatherId: 1271, motherId: 127, spouseIds: [200], childrenIds: [201, 202] },
            { id: 200, name: "Christa Koller (geb. Holl)", details: { geboren: "07.11.1951", gestorben: "08.10.2012", info: "Heirat 08.09.1972 mit Sylvester Koller (*08.04.1949)." }, fatherId: 210, motherId: 211 },
            
            { id: 201, name: "Thomas Koller", details: { geboren: "12.08.1973", gestorben: "13.11.2003" }, fatherId: 1273, motherId: 200 },
            { id: 202, name: "Steffen Koller", details: { geboren: "09.08.1975", info: "Heirat 03.06.2011 mit Mareike Koller (geb. Maier, *18.11.1981)." }, fatherId: 1273, motherId: 200, spouseIds: [300], childrenIds: [301, 302, 303, 304] },
            
            { id: 300, name: "Mareike Koller (geb. Maier)", details: { geboren: "18.11.1981", info: "Heirat 03.06.2011 mit Steffen Koller." }, fatherId: 311, motherId: 310 },
            { id: 301, name: "Madita Pauline Koller", details: { geboren: "06.02.2013" }, fatherId: 202, motherId: 300 },
            { id: 302, name: "Elva Koller", details: { geboren: "01.12.2014" }, fatherId: 202, motherId: 300 },
            { id: 303, name: "Lida Koller", details: { geboren: "24.01.2018" }, fatherId: 202, motherId: 300 },
            { id: 304, name: "Tore Koller", details: { geboren: "03.09.2020" }, fatherId: 202, motherId: 300 },

            // --- Holl Family Line ---
            { id: 205, name: "Georg Holl", details: { geboren: "15.06.1874", gestorben: "28.02.1947", info: "1. Heirat 21.04.1904 mit Pauline geb. Betz (1881-1918). 2. Heirat 20.05.1918 mit Pauline geb. Vollmer (1885-1965)." }, spouseIds: [206, 207], childrenIds: [208, 210] }, // Simplified children for brevity
            { id: 206, name: "Pauline Betz", details: { geboren: "1881", gestorben: "1918" } },
            { id: 207, name: "Pauline Vollmer", details: { geboren: "1885", gestorben: "1965" } },

            { id: 208, name: "Hermann Holl", details: { geboren: "13.09.1906", gestorben: "01.02.1979", info: "Aus 1. Ehe. Heirat 24.06.1940 mit Anna geb. Sparrer (1921-1984)." }, fatherId: 205, motherId: 206 },
            { id: 210, name: "Ernst Holl", details: { geboren: "21.06.1910", gestorben: "24.10.1974", info: "Aus 1. Ehe. Heirat 25.01.1946 mit Anna geb. Fischer (1923-2004)." }, fatherId: 205, motherId: 206, spouseIds: [211], childrenIds: [212, 200] }, // Christa (200) is a child here
            { id: 211, name: "Anna Fischer", details: { geboren: "1923", gestorben: "2004" } },
            { id: 212, name: "Ernst Holl", details: { geboren: "03.12.1946", info: "Heirat 12.05.1979 mit Daniela M. Holl (geb. Hubert, *27.12.1958)." }, fatherId: 210, motherId: 211, spouseIds: [1276] },
            
            { id: 1276, name: "Daniela M. Holl (geb. Hubert)", details: { geboren: "27.12.1958", info: "Tochter von Alfons Hubert. Heirat 10.05.1979 (geschieden) mit Ernst Ludwig Holl (geb. 1946)." }, fatherId: 1272, motherId: 127, spouseIds: [212] },
            // ... other children of Daniela
            
            // --- Maier Family Line ---
            { id: 305, name: "Reinhold & Rose Mögenthaler", details: {}, childrenIds: [310, 312] },
            { id: 306, name: "Ernst & Berta Maier", details: {}, childrenIds: [313, 314] },

            { id: 310, name: "Dagmar Maier (geb. Mögenthaler)", details: {"info": "verh. mit Rolf Maier"}, fatherId: 305, spouseIds: [311], childrenIds: [300] }, // Mareike (300) is a child here
            { id: 311, name: "Rolf Maier", details: {} },
            { id: 312, name: "Rose Maier (geb. Mögenthaler)", details: {"info": "verh. mit Wolfgang Maier"}, fatherId: 305, spouseIds: [314] },
            { id: 313, name: "Erwin Maier", details: {"info": "verh. mit Elfriede"}, fatherId: 306 },
            { id: 314, name: "Wolfgang Maier", details: {"info": "verh. mit Rose Mögenthaler"}, fatherId: 306, spouseIds: [312] },

            // NOTE: This is a simplified version of your data. 
            // Many individuals from the original file are omitted for clarity of the new structure.
            // The full dataset would include all original persons with their new ID-based relationships.
        ];

        // --- D3.js Visualization Code ---
        
        // Global variables
        let svg, g, zoom, tooltip, tooltipName, tooltipDetails;
        let root, flatData, selectedNode, initialTransform;
        let allPeopleMap = new Map();
        let maxVisibleDepth = 1;
        let switchToVerticalAtDepth = 99; 
        const width = window.innerWidth;
        const height = window.innerHeight;
        const treeLayout = d3.tree().nodeSize([160, 220]);

        // --- DATA PROCESSING ---

        /**
         * Initializes the master data map from the flat array.
         */
        function initializeMasterData() {
            allPeopleMap.clear();
            peopleData.forEach(p => {
                // Ensure details object exists
                if (!p.details) p.details = {};
                allPeopleMap.set(p.id, { ...p, children: [], _children: [] });
            });
        }

        /**
         * Builds a hierarchical tree structure from the flat data for a given root person ID.
         * @param {number} rootId - The ID of the person to start the tree from.
         * @param {Map} personMap - The map of all people.
         * @param {Set} visited - A set to track visited nodes and prevent infinite loops.
         * @returns {object|null} A hierarchical object suitable for d3.hierarchy.
         */
        function buildTreeFromFlatData(rootId, personMap, visited = new Set()) {
            if (visited.has(rootId)) {
                return null; // Avoid circular dependencies
            }
            visited.add(rootId);

            const rootPerson = personMap.get(rootId);
            if (!rootPerson) {
                return null;
            }

            // Create a deep copy to avoid modifying the original map data
            const treeNode = JSON.parse(JSON.stringify(rootPerson));
            treeNode.children = [];

            if (rootPerson.childrenIds) {
                rootPerson.childrenIds.forEach(childId => {
                    const childNode = buildTreeFromFlatData(childId, personMap, new Set(visited));
                    if (childNode) {
                        treeNode.children.push(childNode);
                    }
                });
            }
            return treeNode;
        }

        /**
         * Generates an ancestor tree (Ahnentafel) for a given person ID.
         * @param {number} startId - The ID of the person to start from.
         * @param {Map} personMap - The map of all people.
         * @param {number} maxDepth - The maximum number of generations to go back.
         * @returns {object|null} A hierarchical object representing the ancestor tree.
         */
        function generateAhnentafel(startId, personMap, maxDepth = 5) {
            function buildAncestors(personId, depth) {
                if (!personId || depth > maxDepth) {
                    return null;
                }
                const person = personMap.get(personId);
                if (!person) return null;

                const ahnenNode = {
                    name: person.name,
                    data: person, // Keep original data reference
                    details: person.details,
                    children: []
                };

                const father = buildAncestors(person.fatherId, depth + 1);
                const mother = buildAncestors(person.motherId, depth + 1);

                if (father) ahnenNode.children.push(father);
                if (mother) ahnenNode.children.push(mother);

                return ahnenNode;
            }
            return buildAncestors(startId, 1);
        }

        // --- VISUALIZATION SETUP ---

        function initializeVisualization() {
            d3.select("#tree-container").html('');
            
            svg = d3.select("#tree-container").append("svg")
                .attr("width", width)
                .attr("height", height);

            g = svg.append("g");

            tooltip = d3.select("#tooltip");
            tooltipName = d3.select("#tooltip-name");
            tooltipDetails = d3.select("#tooltip-details");

            zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom);
        }
        
        // --- UI CONTROLS ---

        function createControls(maxDepth) {
            const container = d3.select("#controls-container");
            container.html(''); 

            const header = container.append('div').attr('class', 'panel-header');
            header.append('span').text('Ansicht & Steuerung');
            header.append('svg').attr('viewBox', '0 0 20 20').attr('fill', 'currentColor')
              .html(`<path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />`);
            
            const content = container.append('div').attr('class', 'panel-content');

            header.on('click', () => {
                container.classed('collapsed', !container.classed('collapsed'));
                content.classed('collapsed', !content.classed('collapsed'));
            });

            const viewGroup = content.append('div').attr('class', 'control-group');
            viewGroup.append('label').text('Ansicht wählen:');
            const viewSwitcher = viewGroup.append('div').attr('class', 'view-switcher grid grid-cols-2 sm:grid-cols-4 gap-1');
            
            viewSwitcher.append('div').html('<input type="radio" id="view-koller" name="view" value="koller" checked><label for="view-koller">Koller</label>');
            viewSwitcher.append('div').html('<input type="radio" id="view-holl" name="view" value="holl"><label for="view-holl">Holl</label>');
            viewSwitcher.append('div').html('<input type="radio" id="view-maier" name="view" value="maier"><label for="view-maier">Maier</label>');
            viewSwitcher.append('div').html('<input type="radio" id="view-ahnentafel" name="view" value="ahnentafel"><label for="view-ahnentafel">Ahnentafel</label>');

            d3.selectAll('input[name="view"]').on('change', function() {
                renderTree(this.value);
            });

            const searchGroup = content.append('div').attr('class', 'control-group mt-2 search-container').attr('id', 'search-container');
            searchGroup.append('label').attr('for', 'search-input').text('Person suchen:');
            searchGroup.append('input')
                .attr('type', 'text')
                .attr('id', 'search-input')
                .attr('placeholder', 'Name eingeben...');
            searchGroup.append('div').attr('class', 'search-results');

            const depthGroup = content.append('div').attr('class', 'control-group mt-2').attr('id', 'depth-control');
            const depthRow = depthGroup.append('div').attr('class', 'control-row');
            depthRow.append('label').attr('for', 'depth-switch').text('Ebenen anzeigen:');
            const depthSelect = depthRow.append('select').attr('id', 'depth-switch')
                .on('change', function() {
                    maxVisibleDepth = parseInt(this.value);
                    setTreeVisibility(root, maxVisibleDepth);
                    update(root);
                });
            
            for (let i = 1; i <= maxDepth; i++) {
                depthSelect.append('option').attr('value', i).text(i)
                    .property('selected', i === maxVisibleDepth);
            }
            
            const buttonGroup = content.append('div').attr('class', 'control-group mt-2 flex-col space-y-2');
            buttonGroup.append('button').attr('id', 'reset-button').text('Ansicht zurücksetzen');
            buttonGroup.append('button').attr('id', 'zoom-button').text('Auf Auswahl zoomen').attr('class', 'primary');

            d3.select('#search-input').on('input', handleSearch);
            d3.select('#reset-button').on('click', handleReset);
            d3.select('#zoom-button').on('click', handleZoomToSelection);
        }
        
        // --- D3 UPDATE LOGIC ---
        
        function setTreeVisibility(node, depth) {
            if (!node.children && node._children) {
                 node.children = node._children;
            }
            
            if (node.depth >= depth) {
                if(node.children) node._children = node.children;
                node.children = null;
            } else if (node._children) {
                node.children = node._children;
                node.children.forEach(c => setTreeVisibility(c, depth));
            }
        }

        function findMaxDepth(node) {
            let max = node.depth;
            if (node.children) {
                node.children.forEach(child => {
                    max = Math.max(max, findMaxDepth(child));
                });
            }
            if (node._children) {
                 node._children.forEach(child => {
                    max = Math.max(max, findMaxDepth(child));
                });
            }
            return max;
        }

        function update(source) {
            const duration = 500;
            
            const treeData = treeLayout(root);
            let nodes = treeData.descendants();
            let links = treeData.links();

            const node = g.selectAll("g.node").data(nodes, d => d.data.id); // Use person ID for data binding

            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${source.x0},${source.y0})`)
                .on("click", (event, d) => click(d))
                .on("mouseover", (event, d) => mouseover(event, d.data))
                .on("mouseout", mouseout);

            nodeEnter.append("circle").attr("r", 1e-6);
            nodeEnter.append("text").text(d => d.data.name);

            const nodeUpdate = nodeEnter.merge(node);
            nodeUpdate.transition().duration(duration).attr("transform", d => `translate(${d.x},${d.y})`);
            
            nodeUpdate.select("text").transition().duration(duration)
                .attr("x", 0)
                .attr("y", 30)
                .attr("text-anchor", "middle");

            nodeUpdate.select("circle").transition().duration(duration).attr("r", 10)
                .style("fill", d => d._children ? "#0ea5e9" : "#fff");
            
            const nodeExit = node.exit().transition().duration(duration)
                .attr("transform", d => `translate(${source.x},${source.y})`).remove();
            nodeExit.select("circle").attr("r", 1e-6);
            nodeExit.select("text").style("fill-opacity", 1e-6);

            const link = g.selectAll("path.link").data(links, d => d.target.data.id);

            const linkEnter = link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", d => {
                    const o = { x: source.x0, y: source.y0 };
                    return elbow(o, o);
                });

            linkEnter.merge(link).transition().duration(duration)
                .attr("d", d => elbow(d.source, d.target));

            link.exit().transition().duration(duration)
                .attr("d", d => {
                    const o = { x: source.x, y: source.y };
                    return elbow(o, o);
                }).remove();
            
            highlightBranch(selectedNode);
            nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
        }
        
        function elbow(s, d) {
            return `M${s.x},${s.y}V${(s.y + d.y) / 2}H${d.x}V${d.y}`;
        }

        function highlightBranch(d) {
            d3.selectAll('.node').classed('highlight descendant-highlight', false);
            d3.selectAll('.link').classed('descendant-highlight', false);

            if (!d) return;

            const descendantNodes = d.descendants();
            const descendantIds = new Set(descendantNodes.map(n => n.data.id));

            d3.selectAll('.node').each(function(node_d) {
                const isDescendant = descendantIds.has(node_d.data.id);
                d3.select(this).classed('highlight', node_d.data.id === d.data.id);
                d3.select(this).classed('descendant-highlight', isDescendant && node_d.data.id !== d.data.id);
            });

            d3.selectAll('.link').each(function(link_d) {
                const isDescendantLink = descendantIds.has(link_d.source.data.id) && descendantIds.has(link_d.target.data.id);
                d3.select(this).classed('descendant-highlight', isDescendantLink);
            });
        }

        // --- EVENT HANDLERS ---

        function click(d) {
            selectedNode = d;
            if (d.children) {
                d._children = d.children;
                d.children = null;
                highlightBranch(d.parent);
                selectedNode = d.parent;
            } else {
                d.children = d._children;
                d._children = null;
                highlightBranch(d);
            }
            update(d);
        }
        
        function mouseover(event, d) {
            tooltip.transition().duration(200).style("opacity", .95);
            let detailsHTML = '';
            const details = d.details;
            if (details) {
                if (details.geboren || details.gestorben) {
                    detailsHTML += `<p><strong>Lebensdaten:</strong> ${details.geboren || '?'} - ${details.gestorben || '?'}</p>`;
                }
                if (details.info) {
                    detailsHTML += `<p class="mt-2"><strong>Info:</strong> ${details.info}</p>`;
                }
            }
            tooltipName.text(d.name);
            tooltipDetails.html(detailsHTML || 'Keine weiteren Details verfügbar.');
            
            const tooltipWidth = tooltip.node().offsetWidth;
            const tooltipHeight = tooltip.node().offsetHeight;
            let left = event.pageX + 15;
            let top = event.pageY - 28;
            if (left + tooltipWidth > window.innerWidth) {
                left = event.pageX - tooltipWidth - 15;
            }
            if (top + tooltipHeight > window.innerHeight) {
                top = event.pageY - tooltipHeight;
            }
            tooltip.style("left", left + "px").style("top", top + "px");
        }

        function mouseout(event, d) {
            tooltip.transition().duration(500).style("opacity", 0);
        }

        function showPathAndCenter(d) {
            selectedNode = d;
            let ancestors = d.ancestors();
            
            root.descendants().forEach(node => {
                if (ancestors.indexOf(node) < 0 && node.children) {
                    node._children = node.children;
                    node.children = null;
                }
            });

            ancestors.forEach(anc => {
                if(anc._children) {
                    anc.children = anc._children;
                }
            });

            update(d);

            setTimeout(() => {
                const scale = 0.8;
                const transform = d3.zoomIdentity
                    .translate(width / 2 - d.x * scale, height / 2 - d.y * scale)
                    .scale(scale);
                
                svg.transition().duration(750).call(zoom.transform, transform);
                highlightBranch(d);
            }, 550);
        }

        function handleSearch(event) {
            const value = this.value.toLowerCase();
            const resultsContainer = d3.select(this.parentNode).select('.search-results');
            resultsContainer.html('');

            if (value.length < 2) return;

            const results = [];
            const searchPool = Array.from(allPeopleMap.values());

            searchPool.forEach(p => {
                if (p.name.toLowerCase().includes(value)) {
                    results.push({ displayName: p.name, targetId: p.id });
                }
            });
            
            const uniqueResults = Array.from(new Map(results.map(item => [item.displayName, item])).values());

            uniqueResults.forEach(res => {
                resultsContainer.append('div')
                    .attr('class', 'search-result-item')
                    .text(res.displayName)
                    .on('click', () => {
                        const currentView = d3.select('input[name="view"]:checked').node().value;
                        if (currentView === 'ahnentafel') {
                            const ahnentafelData = generateAhnentafel(res.targetId, allPeopleMap);
                            if (ahnentafelData) {
                                renderTree('ahnentafel', ahnentafelData);
                            }
                        } else {
                            const targetNode = root.descendants().find(n => n.data.id === res.targetId);
                            if (targetNode) {
                                showPathAndCenter(targetNode);
                            }
                        }
                        resultsContainer.html('');
                        this.value = '';
                    });
            });
        }
        
        function handleReset() {
            const currentView = d3.select('input[name="view"]:checked').node().value;
            renderTree(currentView);
        }

        function handleZoomToSelection() {
            if (selectedNode) {
                const scale = 0.8;
                const transform = d3.zoomIdentity
                    .translate(width / 2 - selectedNode.x * scale, height / 2 - selectedNode.y * scale)
                    .scale(scale);
                svg.transition().duration(750).call(zoom.transform, transform);
            }
        }

        // --- MAIN RENDER FUNCTION ---

        function renderTree(viewKey, customData = null) {
            let data, title;
            const rootIds = { koller: 1, holl: 205, maier: 305 };
            const titles = { koller: "Stammbaum Familie Koller", holl: "Stammbaum Familie Holl", maier: "Stammbaum Familie Maier" };
            
            const searchLabel = d3.select('#search-container label');
            const depthControl = d3.select('#depth-control');

            if (viewKey === 'ahnentafel') {
                title = "Ahnentafel";
                if(searchLabel.node()) searchLabel.text('Ahnentafel für:');
                if(depthControl.node()) depthControl.style('display', 'none');

                if (customData) {
                    data = customData;
                    title = `Ahnentafel ${data.name}`;
                } else {
                    // Default to my (Steffen Koller's) ancestor chart
                    data = generateAhnentafel(202, allPeopleMap);
                }
            } else {
                if(searchLabel.node()) searchLabel.text('Person suchen:');
                if(depthControl.node()) depthControl.style('display', 'flex');
                
                data = buildTreeFromFlatData(rootIds[viewKey], allPeopleMap);
                title = titles[viewKey];
            }
            d3.select('#main-title').text(title);

            initializeVisualization();
            
            selectedNode = null;
            maxVisibleDepth = (viewKey === 'ahnentafel') ? 10 : 2; 

            root = d3.hierarchy(data, d => d.children);
            
            const tempRootForDepth = d3.hierarchy(JSON.parse(JSON.stringify(data)), d => d.children);
            const maxDataDepth = findMaxDepth(tempRootForDepth);
            
            createControls(maxDataDepth);
            
            d3.select(`#view-${viewKey}`).property('checked', true);
            d3.select('#depth-switch').property('value', maxVisibleDepth);
            if (viewKey === 'ahnentafel') {
                d3.select('#depth-control').style('display', 'none');
            }

            root.descendants().forEach((d, i) => {
                d._children = d.children;
            });
            
            flatData = root.descendants();
            setTreeVisibility(root, maxVisibleDepth);

            root.x0 = width / 2;
            root.y0 = 0;
            update(root);
            
            const yOffset = (viewKey === 'ahnentafel') ? height / 2 : 120;
            const scale = (viewKey === 'ahnentafel') ? 0.6 : 0.7;
            initialTransform = d3.zoomIdentity.translate(width / 2, yOffset).scale(scale);
            svg.call(zoom.transform, initialTransform);
        }

        // --- Initial Setup ---
        initializeMasterData();
        renderTree('koller');

        window.addEventListener('resize', () => {
            const currentView = d3.select('input[name="view"]:checked').node().value;
            renderTree(currentView);
        });

    </script>
</body>
</html>
